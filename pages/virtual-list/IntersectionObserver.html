<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>虚拟列表-IntersectionObserver方案</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      align-content: center;
      justify-content: center;
      align-items: center;
    }

    #container {
      position: relative;
      width: 400px;
      height: 600px;
      overflow: hidden auto;
      border: 1px solid #4ba946;
    }

    #phantom {
      width: 100%;
    }

    #list {
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    #list > .item {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      align-content: center;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 70px;
    }

    #list > .item + .item {
      border-top: 1px solid #4ba946;
    }
  </style>
</head>
<body>
<div id="container">
  <!-- 用于生成滚动条 -->
  <div id="phantom"></div>
  <div id="list">

  </div>
</div>
</body>
<script>
  /*
  * 虚拟列表IntersectionObserver方案（这种方案要比scrollTop方案性能要高一点）
  * - 背景：正常情况下我们会将某个列表的数据全部渲染到页面上，但是假如有几十甚至上百万条数据，
  *        一次性渲染及其消耗性能并且会让用户等待较长一段时间，这时候虚拟列表就有作用了
  * - 思路：虚拟列表是一种按需渲染的实现，即只渲染列表高度内的数据，列表高度外的数据不渲染，这种实现的渲染性能很高
  * - 原理：
  *   1.利用IntersectionObserver(https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)
  *     监视首尾元素是否与容器元素橡胶（出现在可视区域内），首尾中有一个未相交，则从新计算
  *   2.为保证初始渲染时首尾元素都出现在可是区域内，计算可视区域内渲染元素个数应向下取整
  * */

  (function () {
    const data = [],
      documentFragment = document.createDocumentFragment(),
      list = document.querySelector('#list'),
      container = document.querySelector('#container'),
      phantom = document.querySelector('#phantom'),
      itemHeight = 70
    let startIndex = 0,
      endIndex = 0,
      visibleNum = 0
    const intersectionObserver = new IntersectionObserver(function (entries, observer) {
      //当是两个入口，且入口都与列表容器相交（即都在可视区域内），则是初始渲染或者计算后的结果
      if (entries.length === 2 && entries[0].isIntersecting && entries[1].isIntersecting) return
      entries.forEach(entry => observer.unobserve(entry.target))
      startIndex = Math.floor(container.scrollTop / itemHeight)
      endIndex = startIndex + visibleNum
      list.innerHTML = ''
      list.style.setProperty('transform', `translateY(${startIndex * itemHeight}px)`)
      render()
    }, {
      root: container
    })
    const init = () => {
      //列表总高度，主要作用是滚动条效果
      phantom.style = `height:${itemHeight * data.length}px;`
      //向下取整（方便IntersectionObserver判断跳出条件）
      visibleNum = Math.floor(container.clientHeight / itemHeight)
      endIndex = visibleNum - 1
      render()
    }
    const render = () => {
      //将元素添加到文档片段然后一次性添加到DOM树中要比逐次添加到DOM树中性能要高
      for (let i = startIndex; i <= endIndex; i++) {
        const div = document.createElement('div')
        div.classList.add('item')
        div.dataset.index = i
        div.innerText = data[i].name
        documentFragment.appendChild(div)
      }
      list.append(documentFragment)
      //监视首尾元素
      intersectionObserver.observe(list.firstElementChild)
      intersectionObserver.observe(list.lastElementChild)
    }

    for (let i = 0; i < 1000000; i++) {
      data.push({
        id: i,
        name: `第 ${i} 条`
      })
    }

    init()
  })()
</script>
</html>