<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>时间动画</title>
  <style>
      html, body {
          width: 100%;
          height: 100%;
          background: #000;
          overflow: hidden;
      }
  </style>
</head>
<body>
<canvas></canvas>
</body>
<script>
  (function () {
    const {body: {clientWidth, clientHeight}} = document,
      {PI} = Math
    const step = 15
    /*
      实现思路：
        1.获取本地事件，然后绘制到canvas上（文字一定要有颜色）
        2.利用getImageData获取文字的像素坐标（每四个数据为一个坐标的颜色值，第四个数据不为0时为文字的一个像素），
          为了点位看起来不那么密集，可以设定每隔一定距离取一个像素点
          小技巧：遍历数据时由y及x会将图像变化达到最小
        3.生成最大像素点点数（88:88:88所需要的像素点数比较多）
        4.初始渲染时将各粒子点位打断，然后获取时间文本点位，设置点位运动终点为像素点位
        5.每一帧动画由开始点位往终点点位移动一段距离
     */
    Array.prototype.shuffle = function () {
      const arr = this
      let i = arr.length - 1
      do {
        const n = randomInt(0, arr.length - 1),
          tem = arr[n]
        arr[n] = arr[i]
        arr[i--] = tem
      } while (i >= 0)
      return arr
    }

    function randomFloat(min, max) {
      return Math.random() * (max - min) + min
    }

    function randomInt(min, max) {
      return ~~(Math.random() * (max - min + 1) + min)
    }

    //生成亮色
    function generateColor() {
      const n1 = randomInt(150, 250),
        n2 = randomInt(100, 250),
        n3 = randomInt(0, 50),
        colorArr = [n1, n2, n3]
      colorArr.shuffle()
      return `rgba(${colorArr[0]},${colorArr[1]},${colorArr[2]},0.8)`
    }

    class Particle {
      constructor(x, y) {
        this.x = x
        this.y = y
        this.color = generateColor()
        this.size = randomFloat(7, 15)
        this.setStartPos(x, y)
      }

      get speedX() {
        return (this.startX - this.x) / 10
      }

      get speedY() {
        return (this.startY - this.y) / 10
      }

      setStartPos(x, y) {
        const radian = randomFloat(0, 2 * PI),
          offset = randomInt(clientHeight / 2, clientWidth / 2)
        this.startX = x + Math.cos(radian) * offset
        this.startY = y + Math.sin(radian) * offset
        this.x = this.startX
        this.y = this.startY
      }

      move() {
        const {
          x,
          y,
          startX,
          startY,
          speedX,
          speedY
        } = this
        if (startX !== x || startY !== y) {
          this.startY = ~~(startY) === y ? y : startY - speedY
          this.startX = ~~(startX) === x ? x : startX - speedX
        }
      }

      static getOffScreenPos() {
        const w = clientWidth,
          h = clientHeight,
          radius = Math.sqrt(w ** 2 + h ** 2),
          radian = randomFloat(-PI / 4, PI / 4),
          x = w + Math.cos(radian) * radius,
          y = h + Math.sin(radian) * radius
        return {
          x,
          y
        }
      }
    }

    const canvas = document.querySelector('canvas')
    if (!canvas?.getContext ?? true) return
    const W = canvas.width = clientWidth,
      H = canvas.height = clientHeight,
      particleNum = 500,
      ctx = canvas.getContext('2d'),
      particles = []

    /**
     * 根据ImageData获取字的像素坐标，每隔12个像素取一个
     * @returns {[]} 返回{x,y}格式的坐标对象
     */
    function getTextPosArr() {
      const date = new Date(),
        posArr = []
      let hour = date.getHours(),
        minutes = date.getMinutes(),
        seconds = date.getSeconds(),
        imgData
      hour = hour > 9 ? hour : `0${hour}`
      minutes = minutes > 9 ? minutes : `0${minutes}`
      seconds = seconds > 9 ? seconds : `0${seconds}`

      ctx.clearRect(0, 0, W, H)
      ctx.fillStyle = 'red'
      ctx.font = '300px Avenir'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillText(`${hour}:${minutes}:${seconds}`, W / 2, H / 2)

      imgData = ctx.getImageData(0, 0, W, H).data
      for (let j = 0; j < W; j += step) {
        for (let i = 0; i < H; i += step) {
          if (imgData[(i * W + j) * 4] > 0) {
            posArr.push({
              x: j,
              y: i
            })
          }
        }
      }
      ctx.clearRect(0, 0, W, H)
      return posArr
    }

    function init() {
      const posArr = getTextPosArr()
      let i = 0
      do {
        const pos = posArr[i++] ?? Particle.getOffScreenPos()
        particles.push(new Particle(pos.x, pos.y))
      } while (i < particleNum)
      ctx.globalCompositeOperation = 'lighten'
    }

    function render() {
      const posArr = getTextPosArr()
      let i = particles.length - 1
      do {
        const particle = particles[i]
        let pos = posArr[i--] ?? Particle.getOffScreenPos()
        particle.x = pos.x
        particle.y = pos.y
      } while (i >= 0)
      posArr.forEach((pos, i) => {
        particles[i].x = pos.x
        particles[i].y = pos.y
      })
      for (const particle of particles) {
        const {startX, startY, x, y} = particle
        ctx.beginPath()
        ctx.arc(startX, startY, particle.size, 0, 2 * PI)
        ctx.fillStyle = particle.color
        ctx.fill()
        ctx.closePath()
        if (startX !== x || startY !== y) {
          particle.move()
        }
      }
      requestAnimationFrame(render)
    }

    init()
    render()

  })()
</script>
</html>
